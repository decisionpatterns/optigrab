* CONSIDER: flag identifiers /  specification for option name.
    This could be a set of fixed identifiers such as '--' and '--' 
    prefixes OR a function applied to a character vector that indicates
    that the argument is an option name rather than a specifier.

    See, for example, is.flag which requires this.

    options$optigrab$option_identifier

* CONSIDER: 
    - 'greedy' option, i.e. take all values until the next 
       option flag. This can be set at the option levels as in:

          grab_opt( ..., n="greedy" ) 

    - 'up.to(3)', i.e. take up to 3 values

    Both require specifying how options are idenfied, see above.
    It would be 


* CONSIDERING: renaming 'expand_opts' -> 'split_opts' 


* Help semantics: 
  optihelp()
  AUTOHELP()
  AUTOHELP
  _AUTOHELP_ : semantics

  # makeActiveBinding( "option.starter" , f, baseenv(baseenv()) ) 
  
* CONSIDER: optiion bundling

Require exact flag specification vs. match?
exact flag vs. specify flag indicators seperately.  If the flag indicators
are seperate, it allows 

  * Do we enforce single-letter options with  a single-dash?
  * If we do not know what the indicators are, how can we make it
    greedy?
  * How do we specify multiple values:
    n = 1, n = 2, n=1+, .n. >= 0 

DO NOT, INTIALLY SUPPORT BUNDLING
   
* Use match.arg for matching flags?  I don't like this idea as it gets
  too crazy, too quickly    examples.

* n:
  0  Can only be logical. It is possible it is the name of the option
  but why?
  1  Most common
  n  A specific number
  n = up.to(3) 
  n = greedy

If greedy is used ... we should warn about args.


* Read from config file:
  * Prompt?
  * Search on local?
  An option can come from .rc, CLO, prompt or setting.  
  If it is interactive
  

== LESSER ==
* Make this compatible with RApache/Rook (why)


== Completed ==

X  Drop the 'coerce' argument from 'grabOpt' since it is no different from
  wrapping the call in an as.* function.  

